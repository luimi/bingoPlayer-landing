<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />

    <title>BingoPlayer - Analytics</title>
    <script src="https://unpkg.com/parse/dist/parse.min.js"></script>

    <style>
        /* CSS para el Dise√±o Visual */
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f9;
            color: #333;
            height: 100dvh;
            padding: 0;
            margin: 0;
        }

        #container {
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);

            width: 100%;
            height: 100dvh;
            display: flex;
            flex-direction: column;
        }

        #work-area {
            flex: 1;
            display: flex;
            flex-direction: row;
            min-height: 0;
        }



        #image-area {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #e9e9e9;
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid #ddd;
        }

        #card-image {
            max-width: 100%;
            height: 100%;
            object-fit: contain;
            /* Asegura que la imagen sea visible sin cortarse */
        }

        #text-area {
            flex: 0.5;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 6px;
            border: 1px solid #ddd;
            overflow-y: auto;
        }

        #text-content {
            white-space: pre-wrap;
            /* Respeta saltos de l√≠nea y espacios en el texto */
        }

        #controls-area {
            flex: 0;
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            border-top: 1px solid #eee;
        }

        .controls-section {
            display: flex;
            flex: 1;
        }

        .controls-group {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-right: 15px;
        }

        button {
            padding: 10px 15px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            background-color: #007bff;
            color: white;
            transition: background-color 0.3s;
        }

        #delete-btn {
            background-color: floralwhite;
        }

        #send-btn {
            background-color: lightgray;
        }

        button:hover:not(:disabled) {
            background-color: #0056b3;
        }

        button:disabled {
            background-color: #a0a0a0;
            cursor: not-allowed;
        }

        input[type="number"] {
            width: 60px;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            text-align: center;
        }

        #status-message {
            margin-top: 10px;
            color: #dc3545;
            text-align: center;
        }

        @media (max-width: 600px) {
            #work-area {
                flex-direction: column;
            }

            #controls-area {
                flex-direction: column;
            }
        }
    </style>
</head>

<body>

    <div id="container">
        <div id="work-area">
            <div id="image-area">
                <img id="card-image" src="" alt="Imagen de la tarjeta" style="display: none;">
                <span id="loading-image">Cargando imagen...</span>
            </div>

            <div id="text-area">
                <p id="text-content">Cargando datos...</p>
            </div>
        </div>


        <div id="controls-area">
            <div class="controls-section">
                <div class="controls-group">
                    <button id="prev-btn" disabled>&lt;</button>
                    <button id="next-btn" disabled>&gt;</button>
                </div>

                <div class="controls-group">
                    <input type="number" id="page-input" value="1" min="1">
                    <span id="page-info">de ?</span>
                </div>
            </div>
            <div class="controls-section">
                <div class="controls-group">
                    üóëÔ∏è
                    <input type="checkbox" id="auto-delete-btn">
                </div>
                <div class="controls-group">
                    üõ†Ô∏è
                    <input type="checkbox" id="fix-btn">
                </div>
                <div class="controls-group">
                    <button id="send-btn">üõ†Ô∏è</button>
                    <button id="delete-btn">üóëÔ∏è</button>
                </div>
            </div>


        </div>
    </div>

    <p id="status-message"></p>

    <script>
        // JS para la L√≥gica de Parse y Navegaci√≥n
        document.addEventListener('DOMContentLoaded', () => {

            // --- 1. CONFIGURACI√ìN DE PARSE (REEMPLAZA CON TUS CREDENCIALES) ---
            const APP_ID = 'bVQYkCblfINWHl9HkaFmV6SEyVpQWdWXhGxiaz2h'; // Reemplaza esto
            const JS_KEY = 'QmI5XDehxfxD9j118mZGH30PO16iXvjgJLAxOgny'; // Reemplaza esto
            const SERVER_URL = 'https://parseapi.back4app.com'; // Reemplaza esto con tu URL base
            const LS_FIX_KEY = 'fix';
            const LS_AUTODELETE_KEY = 'autoDelete';

            Parse.initialize(APP_ID, JS_KEY);
            Parse.serverURL = SERVER_URL;

            // Clase de Parse a consultar
            const CardsScan = Parse.Object.extend("CardsScan");

            // Variables de estado
            let currentPage = 1;
            let totalObjects = 0;
            const limit = 1; // Solo mostramos 1 registro por "p√°gina"
            let currentObject = null;
            const fix = localStorage.getItem(LS_FIX_KEY);
            const autoDelete = localStorage.getItem(LS_AUTODELETE_KEY);


            // --- 2. MANEJO DE ELEMENTOS DEL DOM ---
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');
            const pageInput = document.getElementById('page-input');
            const pageInfo = document.getElementById('page-info');
            const cardImage = document.getElementById('card-image');
            const loadingImage = document.getElementById('loading-image');
            const textContent = document.getElementById('text-content');
            const statusMessage = document.getElementById('status-message');
            const deleteBtn = document.getElementById('delete-btn');
            const sendBtn = document.getElementById('send-btn');
            const fixBtn = document.getElementById('fix-btn');
            const autoDeleteBtn = document.getElementById('auto-delete-btn');

            fixBtn.checked = fix && fix === 'true';
            autoDeleteBtn.checked = autoDelete && autoDelete === 'true';
            // --- 3. FUNCIONES DE CONSULTA ---

            /**
             * Consulta la clase CardsScan para obtener el total de registros.
             */
            async function fetchTotalCount() {
                try {
                    const query = new Parse.Query(CardsScan);
                    query.equalTo('fix', fix && fix === 'true' ? true : false)
                    totalObjects = await query.count();
                    pageInfo.textContent = `de ${totalObjects}`;
                    pageInput.max = totalObjects;
                    currentPage = totalObjects
                    // Habilita los botones despu√©s de obtener el total
                    updateButtonState();
                } catch (error) {
                    console.error("Error al obtener el total de objetos:", error);
                    statusMessage.textContent = `Error al conectar con Parse: ${error.message}`;
                }
            }

            function md2json(md) {
                try {
                    let cleanedString = md.replace(/```json\n/g, '')
                        .replace(/JSON/g, '')
                        .replace(/\n```/g, '')
                        .replace(/\s+/g, '')
                        .trim();
                    for (let i = 1; i < 10; i++) {
                        cleanedString = cleanedString.replace(new RegExp(`0${i}`, 'g'), i)
                    }
                    //console.log("cleaned", cleanedString)
                    const m3b = cleanedString.match(/\[\[\[[0-9,\[\]\s]*\]\]\]/g);
                    let last;
                    if (m3b) {
                        last = m3b.at(-1);
                    } else {
                        const m2b = cleanedString.match(/\[\[[0-9,\[\]\s]*\]\]/g);
                        if (m2b) last = `[${m2b.at(-1)}]`;
                    }
                    let obj = JSON.parse(last);
                    if (obj.length === 1 && obj[0].length > 5 && obj[0].length % 5 === 0) {
                        const divided = obj[0].reduce((acc, _, i) => {
                            if (i % 5 === 0) {
                                acc.push(obj[0].slice(i, i + 5));
                            }
                            return acc;
                        }, []);
                        obj = divided;
                    }
                    return obj;
                } catch (e) {
                    console.error("Error: ", e.message);
                    console.log(md)
                    return null;
                }
            }

            function validateCards(cards) {
                let result = true;
                cards.forEach(card => {
                    if (card.length !== 5) {
                        result = false;
                        return;
                    }
                    card.forEach(row => {
                        if (row.length !== 5) {
                            result = false;
                            return;
                        }
                    })
                });
                return result;
            }

            /**
             * Consulta y muestra el registro correspondiente a la p√°gina actual.
             * @param {number} page - El n√∫mero de p√°gina (1-based index).
             */
            async function fetchAndDisplayCard(page) {
                if (page < 1 || (totalObjects > 0 && page > totalObjects)) {
                    // Si el n√∫mero de p√°gina est√° fuera de rango, no hacer nada o ajustar
                    console.warn(`P√°gina ${page} fuera de rango. Total: ${totalObjects}`);
                    return;
                }

                // Calcula el 'skip' (offset)
                const skip = (page - 1) * limit;

                // Muestra un estado de carga
                cardImage.style.display = 'none';
                loadingImage.style.display = 'block';
                textContent.textContent = 'Cargando datos del registro...';
                statusMessage.textContent = '';

                try {
                    const query = new Parse.Query(CardsScan);
                    query.limit(limit);
                    query.skip(skip);
                    query.equalTo('fix', fix && fix === 'true' ? true : false)
                    // Opcional: ordenar por fecha de creaci√≥n o un campo espec√≠fico
                    query.ascending("createdAt");
                    const results = await query.find();

                    if (results.length > 0) {
                        currentObject = results[0];

                        // Campos a mostrar
                        const imageUrl = currentObject.get('image');
                        const resultText = currentObject.get('result') || 'No se encontr√≥ campo **result**';
                        const serverText = currentObject.get('server') || 'No se encontr√≥ campo **server**';
                        const obj = md2json(resultText);
                        const validated = obj ? validateCards(obj) : false

                        // Actualizar DOM
                        if (imageUrl) {
                            cardImage.src = imageUrl;
                            cardImage.style.display = 'block';
                            loadingImage.style.display = 'none';
                        } else {
                            cardImage.style.display = 'none';
                            loadingImage.textContent = 'No hay imagen para este registro.';
                            loadingImage.style.display = 'block';
                        }

                        // A√±ade el campo server al contenido de texto para enriquecer la info
                        textContent.innerHTML = `<strong>Proveedor:</strong> ${serverText}<br><br><strong>Valido:</strong>${validated}<br><br><strong>Contenido:</strong><br>${resultText}<br><br><strong>Resultado:</strong>${JSON.stringify(obj)}
                        `;

                        // Actualizar estado de la p√°gina
                        currentPage = page;
                        pageInput.value = page;
                        updateButtonState();

                        if(validated && autoDeleteBtn.checked) {
                            deleteBtn.click();
                        }
                    } else {
                        // Esto no deber√≠a pasar si el total es correcto, pero es un resguardo
                        textContent.textContent = `No ese encontraron registros en la p√°gina ${page}.`;
                        cardImage.style.display = 'none';
                        loadingImage.textContent = 'Sin datos.';
                    }

                } catch (error) {
                    console.error(`Error al consultar la p√°gina ${page}:`, error);
                    statusMessage.textContent = `Error al cargar registro: ${error.message}`;
                    loadingImage.textContent = 'Error de carga.';
                }
            }

            /**
             * Actualiza el estado de los botones (Anterior/Siguiente) y el input.
             */
            function updateButtonState() {
                prevBtn.disabled = currentPage <= 1;
                nextBtn.disabled = currentPage >= totalObjects || totalObjects === 0;

                pageInput.min = 1;
                pageInput.max = totalObjects || 1; // Para evitar min/max inv√°lidos si total es 0
            }

            async function deleteImage(urlImage) {
                const publicId = urlImage.split('/').at(-1).split('.')[0];

                const url = `https://bingoplayer.up.railway.app/analytic?id=${publicId}`;

                await fetch(url, {
                    method: 'DELETE'
                })
                    .then(response => response.json())
                    .then(data => {
                        console.log(data)
                        if (data.result === 'ok') {
                            console.log('Imagen eliminada con √©xito');
                        } else {
                            console.error('Error al eliminar la imagen', data);
                        }
                    })
                    .catch(error => console.error('Error en la solicitud:', error));
            }

            // --- 4. MANEJO DE EVENTOS ---

            // Bot√≥n Anterior
            prevBtn.addEventListener('click', () => {
                if (currentPage > 1) {
                    fetchAndDisplayCard(currentPage - 1);
                }
            });

            // Bot√≥n Siguiente
            nextBtn.addEventListener('click', () => {
                if (currentPage < totalObjects) {
                    fetchAndDisplayCard(currentPage + 1);
                }
            });

            // Input de P√°gina
            pageInput.addEventListener('change', (e) => {
                const newPage = parseInt(e.target.value, 10);

                if (isNaN(newPage) || newPage < 1) {
                    // Restablece al valor actual si no es v√°lido
                    pageInput.value = currentPage;
                    return;
                }

                if (newPage !== currentPage) {
                    // Limita el n√∫mero de p√°gina al total
                    const finalPage = Math.min(newPage, totalObjects > 0 ? totalObjects : newPage);
                    fetchAndDisplayCard(finalPage);
                }
            });

            deleteBtn.addEventListener('click', async () => {
                if (currentObject) {
                    deleteBtn.textContent = "..."
                    deleteBtn.disabled = true;
                    await deleteImage(currentObject.get('image'))
                    await currentObject.destroy();
                    location.reload();
                }
            })

            sendBtn.addEventListener('click', async () => {
                if (currentObject) {
                    currentObject.set('fix', true);
                    await currentObject.save();
                    location.reload();
                }
            })

            fixBtn.addEventListener('change', async (event) => {
                localStorage.setItem(LS_FIX_KEY, event.currentTarget.checked);
                location.reload();
            })

            autoDeleteBtn.addEventListener('change', async (event) => {
                console.log("changed")
                localStorage.setItem(LS_AUTODELETE_KEY, event.currentTarget.checked);
                location.reload();
            })

            // Iniciar la aplicaci√≥n
            fetchTotalCount().then(() => {
                // Solo si hay registros, cargamos el primero
                if (totalObjects > 0) {
                    fetchAndDisplayCard(currentPage);
                } else {
                    textContent.textContent = 'No hay registros en la clase CardsScan.';
                }
            });
        });
    </script>
</body>

</html>